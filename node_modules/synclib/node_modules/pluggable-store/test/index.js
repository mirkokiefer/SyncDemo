// Generated by CoffeeScript 1.3.3
(function() {
  var assert, assertEvent, assertEventsSerial, contains, fileStore, memory, server, store1, testData, _ref,
    __slice = [].slice;

  _ref = require('../lib/index'), server = _ref.server, memory = _ref.memory;

  assert = require('assert');

  contains = require('underscore').contains;

  assertEvent = function(emitter, _arg, cb) {
    var event, expectedArgs;
    event = _arg[0], expectedArgs = _arg[1];
    return emitter.once(event, function() {
      var args, each, i, _i, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      for (i = _i = 0, _len = expectedArgs.length; _i < _len; i = ++_i) {
        each = expectedArgs[i];
        assert.equal(args[i], each);
      }
      return cb();
    });
  };

  assertEventsSerial = function(emitter, events, cb) {
    var first, rest;
    if (events.length === 0) {
      return cb();
    } else {
      first = events[0], rest = 2 <= events.length ? __slice.call(events, 1) : [];
      return assertEvent(emitter, first, function() {
        return assertEventsSerial(emitter, rest, cb);
      });
    }
  };

  store1 = null;

  fileStore = null;

  beforeEach(function() {
    return store1 = memory();
  });

  before(function() {
    return fileStore = server.fileSystem(process.env.HOME + '/test-store');
  });

  after(function(done) {
    return fileStore.adapter["delete"](done);
  });

  testData = [
    {
      key: 'mult1',
      value: 'multval1'
    }, {
      key: 'mult2',
      value: 'multval2'
    }
  ];

  describe('PluggableStore using Memory adapter', function() {
    describe('read/write', function() {
      it('should write and read an object sync', function() {
        store1.write('key1', 'value1');
        return assert.equal(store1.read('key1'), 'value1');
      });
      it('should write and read an object async', function(done) {
        return store1.write('key2', 'value2', function() {
          return store1.read('key2', function(err, res) {
            assert.equal(res, 'value2');
            return done();
          });
        });
      });
      it('should write and read multiple objects', function() {
        store1.writeAll(testData);
        assert.equal(store1.read('mult1'), 'multval1');
        return assert.equal(store1.read('mult2'), 'multval2');
      });
      it('should write and read multiple objects async', function(done) {
        return store1.writeAll(testData, function() {
          return store1.read('mult1', function(err, res) {
            assert.equal(res, 'multval1');
            return done();
          });
        });
      });
      return it('should delete values', function() {
        store1.write('key1', 'value1');
        assert.equal(store1.read('key1'), 'value1');
        store1.remove('key1');
        return assert.equal(store1.read('key1'), void 0);
      });
    });
    describe('events', function() {
      it('should trigger write event on write', function(done) {
        assertEventsSerial(store1, [['write', ['key3', 'value3']], ['written', ['key3', 'value3']]], done);
        return store1.write('key3', 'value3');
      });
      return it('should trigger read event on read', function(done) {
        assertEvent(store1, ['read', ['key3']], done);
        return store1.read('key3');
      });
    });
    describe('keys', function() {
      return it('should return all keys', function() {
        var key, keys, _i, _len;
        store1.writeAll(testData);
        keys = store1.keys();
        for (_i = 0, _len = testData.length; _i < _len; _i++) {
          key = testData[_i].key;
          assert.ok(contains(keys, key));
        }
        return assert.equal(keys.length, testData.length);
      });
    });
    return describe('pipe', function() {
      return it('should pipe the writes on one store to another', function() {
        var store2;
        store2 = memory();
        store1.pipe(store2);
        store1.write('key4', 'value4');
        return assert.equal(store2.read('key4'), 'value4');
      });
    });
  });

  describe('using FileSystem adapter', function() {
    describe('read/write', function() {
      return it('should write and read an object', function(done) {
        return fileStore.write('key2', 'value2', function() {
          return fileStore.read('key2', function(err, res) {
            assert.equal(res, 'value2');
            return done();
          });
        });
      });
    });
    return describe('keys', function() {
      return it('should return all keys', function(done) {
        return store1.writeAll(testData, function() {
          return store1.keys(function(err, keys) {
            var key, _i, _len;
            for (_i = 0, _len = testData.length; _i < _len; _i++) {
              key = testData[_i].key;
              assert.ok(contains(keys, key));
            }
            assert.equal(keys.length, testData.length);
            return done();
          });
        });
      });
    });
  });

}).call(this);
